tags: [python, core-python, programming, interviewprep, functions]  
alias: [Декораторы, Python Decorators, Синтаксический сахар]  
related: [[Python]], [[Функции как объекты первого класса]], [[Модули и Пакеты в Python]]

**Декоратор** — это функция, которая принимает другую функцию в качестве аргумента, добавляет к ней некоторую новую функциональность и возвращает изменённую функцию, не меняя при этом исходный код самой функции.

> **Простая аналогия**: Представьте, что у вас есть готовый текст (ваша функция). Декоратор — это "редактор", который берет ваш текст, оборачивает его в красивую рамку (добавляет функциональность) и отдает вам обратно. Сам текст при этом не менялся.

Декораторы — это яркий пример "синтаксического сахара", так как они предоставляют удобный синтаксис (@) для довольно распространенного паттерна.

### Фундамент: [[Функции как объекты первого класса]]

Декораторы возможны только потому, что в Python функции являются объектами первого класса. Это означает, что с функциями можно обращаться так же, как и с любыми другими объектами (числами, строками, списками):

1. **Присваивать переменной:** my_func = some_function
    
2. **Передавать в качестве аргумента другой функции:** process_data(my_func)
    
3. **Возвращать из другой функции:** return my_func
    

---

## Создание декоратора: Шаг за шагом

Давайте создадим простой декоратор, который будет печатать сообщение до и после вызова функции.

#### 1. "Ручное" декорирование (без @)

```Python
# Шаг 1: Создаем функцию-декоратор. Она принимает функцию `func` в качестве аргумента.
def my_simple_decorator(func):
    # Шаг 2: Внутри определяем "функцию-обертку" (wrapper).
    # Именно она будет возвращена и заменит собой оригинал.
    def wrapper():
        print("Что-то происходит ДО вызова функции.")
        func() # Шаг 3: Вызываем оригинальную функцию.
        print("Что-то происходит ПОСЛЕ вызова функции.")
    
    # Шаг 4: Декоратор возвращает функцию-обертку.
    return wrapper

# Шаг 5: Определяем функцию, которую хотим "украсить".
def say_hello():
    print("Привет!")

# Шаг 6: "Декорируем" ее вручную.
decorated_hello = my_simple_decorator(say_hello)

# Вызываем полученную, "украшенную" функцию.
decorated_hello()
# Вывод:
# Что-то происходит ДО вызова функции.
# Привет!
# Что-то происходит ПОСЛЕ вызова функции.
```

#### 2. Использование синтаксиса @

Синтаксис @ делает то же самое, что и в шаге 6, но автоматически и более читаемо.
```python
def my_simple_decorator(func):
    def wrapper():
        print("Что-то происходит ДО вызова функции.")
        func()
        print("Что-то происходит ПОСЛЕ вызова функции.")
    return wrapper


# Это эквивалентно строке: say_hello = my_simple_decorator(say_hello)
@my_simple_decorator 
def say_hello():
    print("Привет!")

say_hello() # Сразу вызываем функцию, и она уже "украшена"
```

## Декораторы для функций с аргументами и возвращаемыми значениями

Наш простой декоратор сломается, если say_hello будет принимать аргументы. Чтобы создать универсальный декоратор, wrapper должен принимать любые аргументы и передавать их в исходную функцию. Для этого используются *args и **kwargs.

```python
def universal_decorator(func):
    # Наша обертка теперь принимает любые аргументы
    def wrapper(*args, **kwargs):
        print("Декорируем функцию с аргументами...")
        
        # Передаем аргументы в оригинальную функцию
        result = func(*args, **kwargs)
        
        print("Декорирование завершено.")
        
        # Возвращаем результат выполнения оригинальной функции
        return result
    return wrapper

@universal_decorator
def greet(name, message="Как дела?"):
    return f"Привет, {name}! {message}"

print(greet("Анна"))
# Вывод:
# Декорируем функцию с аргументами...
# Декорирование завершено.
# Привет, Анна! Как дела?
```


## functools.wraps — профессиональный подход

Есть одна проблема: после декорирования наша функция greet теряет свою "личность". Если мы проверим её имя или документацию, мы увидим метаданные wrapper, а не greet.

Generated python

```python
print(greet.__name__) # Выведет: 'wrapper'
```

Это может сломать другие инструменты, которые полагаются на интроспекцию (самоанализ) кода. Чтобы это исправить, используется декоратор @wraps из стандартного модуля functools.

**Правильный, "production-ready" шаблон декоратора:**

```python 
import functools

def timing_decorator(func):
    # Используем @functools.wraps для сохранения метаданных оригинальной функции
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        import time
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Функция '{func.__name__}' выполнилась за {end_time - start_time:.4f} секунд")
        return result
    return wrapper

@timing_decorator
def calculate_big_sum(n):
    """Эта функция считает сумму чисел от 0 до n-1."""
    return sum(range(n))

calculate_big_sum(10000000)
print(calculate_big_sum.__name__) # -> 'calculate_big_sum' (правильно!)
print(calculate_big_sum.__doc__)  # -> 'Эта функция считает сумму чисел от 0 до n-1.' (правильно!)
```

### Популярные вопросы на собеседовании

- **"Что такое декоратор?"**
    
    - Ответ: Это функция, которая принимает другую функцию как аргумент, добавляет к ней новую логику и возвращает измененную функцию. Это позволяет модифицировать поведение функции без изменения ее кода.
        
- **"Напишите декоратор для измерения времени выполнения функции."**
    
    - Ответ: Это классическая задача. См. пример с @timing_decorator выше.
        
- **"Какую проблему решает @functools.wraps?"**
    
    - Ответ: Он копирует метаданные (имя, документацию и т.д.) из исходной функции в функцию-обертку. Без него декорированная функция теряет свою "личность", что может помешать отладке и интроспекции.
        
- **"Можно ли передавать аргументы в сам декоратор?"**
    
    - Ответ: Да, для этого нужно создать еще один уровень вложенности — функцию, которая будет принимать аргументы и возвращать декоратор.
        

---