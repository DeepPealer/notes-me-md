tags: [python, core-python, programming, interviewprep, static-analysis]  
alias: [Type Hints, Аннотации типов, Тайп хинтинг]  
related: [[Python]], [[Функциональное программирование (ФП) в Python]], [[Объектно-ориентированное программирование в Python (ООП)]]

**Указания типов (Type Hints)** — это специальный синтаксис, который позволяет "подсказывать", какие типы данных ожидаются в качестве аргументов функции и какой тип данных она возвращает.

> **Ключевой момент**: Сам по себе интерпретатор Python **полностью игнорирует** эти аннотации во время выполнения. Они не делают Python статически типизированным языком. Их основная цель — помощь разработчикам и статическим анализаторам кода.

### Зачем нужны Type Hints?

1. **Улучшение читаемости и документации**: Типы служат отличной документацией. Сразу понятно, какие данные ожидает функция.
    
2. **Обнаружение ошибок до запуска (Static Analysis)**: Специальные инструменты, такие как **Mypy**, **Pyright** или встроенные в IDE (PyCharm, VS Code), могут проанализировать ваш код и найти потенциальные ошибки, связанные с типами (например, передача строки туда, где ожидается число).
    
3. **Улучшение автодополнения в IDE**: Редактор кода лучше понимает, какие атрибуты и методы есть у ваших переменных, и предлагает более точные подсказки.
    

---

### Базовый синтаксис

- Для переменных и аргументов: variable: type
    
- Для возвращаемого значения функции: -> type
```python
# Простая функция с аннотациями типов
def greet(name: str) -> str:
    return f"Hello, {name}"

# Аннотация для переменной
user_name: str = "Alice"

# Статический анализатор (например, Mypy) увидит здесь ошибку,
# так как мы передаем int вместо str. Python во время выполнения ошибки не выдаст.
# greet(123)
```

## Модуль typing

Для описания более сложных типов (списки, словари и т.д.) используется стандартный модуль typing.

- **До Python 3.9**: Нужно было импортировать типы с заглавной буквы: from typing import List, Dict, Tuple.
    
- **Начиная с Python 3.9+**: Можно использовать встроенные типы с маленькой буквы: list, dict, tuple. Это предпочтительный современный синтаксис.
    

### Основные типы из typing

#### List, Tuple, Set, Dict (до Python 3.9) или list, dict (Python 3.9+)

Указывают тип контейнера и типы его элементов.

```python
# Python 3.9+
def process_scores(scores: list[int]) -> None:
    for score in scores:
        print(score)

def get_user_data(user_id: int) -> dict[str, str | int]: # Значение может быть str или int
    # ...
```


#### Optional[T]

Optional[T] — это сокращение для Union[T, None]. Используется, когда аргумент может быть либо определенного типа, либо None.

```python
from typing import Optional

def find_user(user_id: int) -> Optional[str]:
    if user_id in db:
        return db[user_id]
    return None # Явно указываем, что функция может вернуть None
```


#### Union[T1, T2]

Указывает, что значение может быть одного из нескольких типов. Начиная с Python 3.10 можно использовать более короткий синтаксис |.

```python
# Python 3.10+
def format_id(item_id: str | int) -> str:
    return f"ID-{item_id}"
```


#### Any

Говорит статическому анализатору, что здесь может быть абсолютно любой тип. Используйте Any с осторожностью, так как это фактически отключает проверку типов для данной переменной.

#### Callable

Описывает функции и другие вызываемые объекты.  
Callable[[Arg1Type, Arg2Type], ReturnType]

```python
from typing import Callable

def run_operation(operation: Callable[[int, int], int], a: int, b: int) -> None:
    result = operation(a, b)
    print(f"Результат: {result}")

def add(x: int, y: int) -> int:
    return x + y

run_operation(add, 10, 5) # -> Результат: 15
```

### Статическая проверка с Mypy

Mypy — это самый популярный статический анализатор типов для Python.

1. Установите его: pip install mypy
    
2. Создайте файл my_app.py с ошибкой типов:
`
```python
def double(number: int) -> int:
    return number * 2

double("hello")
```

3. Запустите Mypy из командной строки: mypy my_app.py
    
4. Получите отчет об ошибке:  
    my_app.py:4: error: Argument 1 to "double" has incompatible type "str"; expected "int" [arg-type]
    

---

### Популярные вопросы на собеседовании

- **"Влияют ли аннотации типов на производительность кода?"**
    
    - Ответ: Нет, интерпретатор Python игнорирует их во время выполнения, поэтому они не создают никакой дополнительной нагрузки.
        
- **"Зачем нужны Type Hints, если Python все равно остается динамически типизированным?"**
    
    - Ответ: Их основная цель — не изменить природу Python, а предоставить инструменты для статического анализа, улучшения читаемости кода и помощи IDE. Они позволяют отлавливать определенный класс ошибок до того, как код будет запущен.
        
- **"В чем разница между Union[str, int] и Any?"**
    
    - Ответ: Union[str, int] — это точное указание, что переменная может быть только строкой или целым числом. Это позволяет анализатору продолжать проверку. Any — это "джокер", который говорит анализатору "здесь может быть что угодно, не проверяй это", что ослабляет статическую проверку.
        
- **"Что такое duck typing (утиная типизация) и как она соотносится с аннотациями типов?"**
    
    - Ответ: Утиная типизация — это концепция, где важна не принадлежность объекта к классу, а наличие у него нужных методов. Аннотации типов и утиная типизация не противоречат друг другу. С помощью **протоколов** (typing.Protocol) можно статически проверять, что объект соответствует "утиному" интерфейсу, не наследуясь от конкретного класса.