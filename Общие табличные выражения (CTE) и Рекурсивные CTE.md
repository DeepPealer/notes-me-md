tags: [sql, postgresql, database, bigdata, interviewprep, cte]  
alias: [CTE, WITH, Common Table Expression, Рекурсивные CTE]  
related: [[SQL]], [[SELECT запросы в SQL]], [[Оконные функции (Window Functions)]], [[Подзапросы (Subqueries)]], [[Графы (Graphs)]]

Предложение WITH, также известное как **Common Table Expression (CTE)**, позволяет создавать временные именованные наборы результатов, которые существуют только на время выполнения одного SQL-запроса.

> **Основная идея**: CTE — это способ разбить сложный запрос на простые, логические и читаемые шаги. Вы даете имя подзапросу, а затем ссылаетесь на него как на обычную таблицу.

## [[Общие табличные выражения (CTE)]] (нерекурсивные)

**Аналогия**: Представьте, что вы объявляете временные переменные перед написанием основного блока кода. Это делает код чище и понятнее.

**Когда использовать?**

- Чтобы избежать вложенных [[Подзапросы (Subqueries)|подзапросов]] и сделать запрос "плоским" и более читаемым.
    
- Когда нужно сослаться на один и тот же подзапрос несколько раз в рамках одного большого запроса.
    
- Чтобы структурировать запросы с [[Оконные функции (Window Functions) в SQL|оконными функциями]].
    

**Синтаксис и Пример:**  
Возьмем задачу из предыдущей темы: "Найти 3 самых высокооплачиваемых сотрудника в каждом отделе".
```SQL
WITH RankedEmployees AS (
    -- Шаг 1: Создаем временную таблицу 'RankedEmployees'
    -- В ней будут сотрудники с их рангом по зарплате внутри отдела
    SELECT
        name,
        department,
        salary,
        DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rnk
    FROM employees
)
-- Шаг 2: Теперь просто и понятно выбираем из этой временной таблицы
SELECT name, department, salary
FROM RankedEmployees
WHERE rnk <= 3;
```

Этот код намного чище, чем версия с подзапросом: SELECT * FROM (SELECT ..., DENSE_RANK()... FROM employees) WHERE rnk <= 3;

Можно определять несколько CTE подряд, разделяя их запятыми.

```SQL
WITH
DepartmentAvg AS ( -- Первый CTE
    SELECT department, AVG(salary) as avg_salary
    FROM employees
    GROUP BY department
),
TopDepartments AS ( -- Второй CTE, который может использовать первый
    SELECT department
    FROM DepartmentAvg
    WHERE avg_salary > 85000
)
SELECT *
FROM employees
WHERE department IN (SELECT department FROM TopDepartments);
```

## [[Рекурсивные CTE]]

Рекурсивное CTE — это специальный вид WITH, который может ссылаться сам на себя. Это позволяет выполнять обход иерархических структур или графов.

**Обязательная структура рекурсивного CTE:**
```CQL
WITH RECURSIVE <cte_name> AS (
    -- 1. Базовый случай (Non-Recursive term)
    -- Это "якорь" или начальная точка рекурсии. Он выполняется один раз.
    SELECT ...
    
    UNION ALL -- Обязательно UNION ALL, а не UNION

    -- 2. Рекурсивный случай (Recursive term)
    -- Этот запрос выполняется многократно.
    -- Он должен ссылаться на сам <cte_name>
    SELECT ... FROM <cte_name> JOIN ...
)
SELECT * FROM <cte_name>;
```

**Когда использовать?**

- Для обхода организационной структуры (менеджеры и их подчиненные).
    
- Для отображения иерархии категорий товаров.
    
- Для поиска путей в [[Графы (Graphs)|графе]] (например, "найти все возможные авиаперелеты из города А").
    

**Пример:**  
Представим таблицу employees с колонкой manager_id. Найдем всех подчиненных (прямых и непрямых) для менеджера 'Peter'.

**Таблица employees_hierarchy:**  
| id | name | manager_id |  
|----|-------|------------|  
| 1 | John | 3 |  
| 2 | Jane | 3 |  
| 3 | Peter | NULL | (Директор)  
| 4 | Alice | 1 |  
| 5 | Bob | 4 |

```SQL
WITH RECURSIVE Subordinates AS (
    -- 1. Базовый случай: Находим самого Peter'а. Это наша отправная точка.
    SELECT id, name, manager_id, 0 AS level
    FROM employees_hierarchy
    WHERE name = 'Peter'

    UNION ALL

    -- 2. Рекурсивный случай: Находим сотрудников,
    -- у которых manager_id совпадает с id сотрудника из предыдущего шага.
    SELECT e.id, e.name, e.manager_id, s.level + 1
    FROM employees_hierarchy e
    JOIN Subordinates s ON e.manager_id = s.id
)
SELECT name, level FROM Subordinates;
```

**Результат:**  
| name | level |  
|-------|-------|  
| Peter | 0 |  
| John | 1 |  
| Jane | 1 |  
| Alice | 2 |  
| Bob | 3 |

---

### Популярные вопросы на собеседовании

- **"Когда вы будете использовать CTE вместо подзапроса?"**
    
    - Ответ: Я использую CTE, чтобы улучшить читаемость и структуру сложных запросов, особенно если вложенность подзапросов становится большой или если мне нужно использовать один и тот же результат подзапроса несколько раз.
        
- **"Объясните, как работает рекурсивный CTE."**
    
    - Ответ: Он состоит из двух частей. Сначала выполняется "базовый" или "якорный" запрос, его результат становится первым рабочим набором. Затем итеративно выполняется "рекурсивный" запрос, который на каждом шаге использует результаты предыдущего шага, пока рекурсивная часть не перестанет возвращать новые строки.
        
- **"В чем разница между UNION и UNION ALL в рекурсивном CTE? Почему нужно использовать UNION ALL?"**
    
    - Ответ: UNION ALL просто добавляет новые результаты к уже существующим. UNION пытается удалить дубликаты, что в рекурсивном запросе может привести к бесконечному циклу, если есть циклические ссылки в данных. Поэтому стандарт SQL требует использования UNION ALL.