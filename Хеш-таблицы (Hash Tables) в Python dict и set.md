tags: [python, bigdata, datastructures, algorithms, interviewprep]  
alias: [Хеш-таблица, Хеш-мап, Словарь, Множество, dict, set]  
related: [[Algorithms and Data Structures]], [[Python list (Динамический массив)]], [[Временная и Пространственная Сложность (Big O Notation)]]

Хеш-таблица — это структура данных, которая позволяет хранить и извлекать данные с **невероятно высокой скоростью**. Её главная цель — обеспечить выполнение операций поиска, вставки и удаления в среднем за [[O(1)]] (константное) время.

В Python хеш-таблицы реализованы в виде двух ключевых встроенных типов:

1. **dict (словарь)**: хранит пары ключ: значение.
    
2. **set (множество)**: хранит только уникальные элементы (ключи).
    

---

## Как это работает: Магия под капотом

Чтобы достичь O(1), хеш-таблица использует умный трюк, состоящий из двух частей:

### 1. Хеш-функция (hash())

Это "волшебная" функция, которая преобразует **ключ** любого размера (строку, число, кортеж) в **целое число** фиксированного размера, называемое **хешем** или **хеш-кодом**.

```Python
print(f"Хеш для 'hello': {hash('hello')}")
print(f"Хеш для 123: {hash(123)}")
print(f"Хеш для кортежа (1, 'a'): {hash((1, 'a'))}")
```

У хорошей хеш-функции два свойства:

- **Детерминированность**: Для одного и того же ключа она всегда возвращает один и тот же хеш.
    
- **Эффективное распределение**: Она старается выдавать разные хеши для разных ключей, чтобы минимизировать совпадения.
    

### 2. Массив ("Корзины" или "Buckets")

В основе хеш-таблицы лежит обычный [[Массивы и Связные списки в Python|массив]]. Хеш, полученный от ключа, используется для вычисления **индекса** в этом массиве. Самый простой способ: index = hash(key) % array_size.

**Процесс вставки (например, my_dict['name'] = 'Alice')**:

1. **Хеширование ключа**: Python вычисляет hash('name') -> (получаем какое-то большое число).
    
2. **Вычисление индекса**: Это число превращается в индекс массива, например, индекс = hash('name') % 16. Допустим, получили индекс = 5.
    
3. **Сохранение**: Пара ('name', 'Alice') помещается в "корзину" (bucket) по индексу 5.

## Проблема: Коллизии

Что если два разных ключа дают один и тот же индекс? Например, hash('key1') % 16 и hash('key2') % 16 оба равны 5. Это называется **коллизией**.

Python решает эту проблему методом **цепочек (Separate Chaining)**.

- Каждая "корзина" в массиве — это не просто ячейка, а указатель на [[Массивы и Связные списки в Python|связный список]] (или другую структуру).
    
- Если происходит коллизия, новая пара (ключ, значение) просто добавляется в конец этого списка.
    

**Последствия**: Когда мы ищем элемент, мы сначала вычисляем индекс, переходим в нужную корзину, а затем **проходим по короткому связному списку**, сравнивая искомый ключ с ключами в списке.

> **Важно**: Если хеш-функция плохая или нам очень не повезло, все ключи могут попасть в одну корзину. Тогда хеш-таблица "вырождается" в связный список, и все операции становятся [[O(n)]]. Но на практике это случается крайне редко.

---

## dict и set в Python

### dict (Словарь)

Ключевая реализация хеш-таблицы для хранения пар ключ: значение.

**Требование к ключам**: Ключи в словаре должны быть **хешируемыми (hashable)**. Это значит, что:

1. Объект имеет метод __hash__(), который возвращает целое число.
    
2. Объект имеет метод __eq__(), который сравнивает его с другими объектами.
    
3. Хеш объекта **не изменяется** в течение его жизни.
    

Вот почему **неизменяемые (immutable)** типы, такие как str, int, float, tuple, могут быть ключами, а **изменяемые (mutable)**, такие как list, dict, set, — **не могут**.
```Python
# Хорошие ключи
my_dict = {
    "name": "Alice",
    123: "is a number",
    (1, 2): "is a tuple"
}

# Плохой ключ -> вызовет TypeError: unhashable type: 'list'
# bad_dict = {[1, 2]: "is a list"}
```

### set (Множество)

Это хеш-таблица, которая хранит только ключи (без значений). Идеально подходит для:

- Хранения уникальных элементов.
    
- Быстрой проверки на принадлежность (item in my_set).
```Python
# Убираем дубликаты из списка за O(n)
data = [1, 2, 'a', 3, 'a', 2, 4]
unique_data = set(data)
print(unique_data) # -> {1, 2, 3, 4, 'a'}

# Быстрая проверка на наличие
if 'a' in unique_data:
    print("'a' существует!") # Выполнится мгновенно
```

### Сложность операций (Big O)

|   |   |   |
|---|---|---|
|Операция|Средний случай|Худший случай|
|**Поиск** (value = d[key], key in d)|[[O(1)]]|[[O(n)]]|
|**Вставка** (d[key] = value)|[[O(1)]]|[[O(n)]]|
|**Удаление** (del d[key])|[[O(1)]]|[[O(n)]]|
|**Пространство**|[[O(n)]]|[[O(n)]]|

**Средний случай O(1) — это то, что вы должны называть на собеседовании по умолчанию.** Уточнение про O(n) в худшем случае покажет ваше глубокое понимание.

---

### Популярные вопросы и задачи на собеседовании

- **"Почему list не может быть ключом в dict?"**
    
    - Ответ: Потому что list — изменяемый тип. Если бы мы использовали список как ключ, а потом изменили его, его хеш бы поменялся, и мы бы никогда не смогли найти исходное значение.
        
- **Задача "Two Sum"**: Дан массив чисел и целевое число. Найдите два числа в массиве, которые в сумме дают это целевое число.
    
    - Решение с хеш-таблицей (O(n)): Идти по массиву. Для каждого элемента x проверять, есть ли в хеш-таблице (target - x). Если нет, добавлять x в таблицу.
        
- **Задача "Найти первого неповторяющегося символа в строке"**:
    
    - Решение с хеш-таблицей (O(n)): За один проход по строке посчитать частоту каждого символа в словаре. За второй проход — найти первый символ с частотой 1.
        

---