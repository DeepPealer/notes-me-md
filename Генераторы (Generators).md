tags: [python, core-python, programming, interviewprep, generators, memory-efficiency, yield]  
alias: [Генераторы, Генераторные функции, Выражения-генераторы, yield]  
related: [[Python]], [[Итераторы (Iterators)]], [[Декораторы (Decorators)]]

**Генератор** — это простой и элегантный способ создания [[Итераторы (Iterators)|итераторов]]. Вместо того чтобы писать полноценный класс с методами __iter__ и __next__, вы пишете обычную функцию, но используете в ней ключевое слово yield.

> **Ключевая идея**: Генераторы — это "фабрики" итераторов. Они автоматически реализуют протокол итератора, позволяя вам сосредоточиться на логике генерации последовательности.

---

### Ключевое слово yield

yield — это то, что отличает генераторную функцию от обычной.

- **return**: Полностью завершает выполнение функции и возвращает значение.
    
- **yield**: "Приостанавливает" выполнение функции, "отдает" (yields) значение наружу и **сохраняет свое состояние** (локальные переменные, текущее место выполнения). При следующем вызове next() исполнение возобновляется с того места, где оно было приостановлено.
    

---

### 1. Генераторные функции

Любая функция, содержащая yield, становится генераторной функцией. При вызове она не выполняет код, а немедленно возвращает **объект-генератор** (который является итератором).

Давайте перепишем наш пример PowerOfTwo из темы про итераторы, используя генератор.

**Версия с классом-итератором (сложно):**

```Python 
class PowerOfTwo:
    def __init__(self, max_power=0):
        # ... много кода ...
    def __iter__(self):
        # ...
    def __next__(self):
        # ...
```

**Версия с генераторной функцией (просто и читаемо):**

```python
def power_of_two_gen(max_power):
    """Генераторная функция для степеней двойки."""
    current_power = 0
    while current_power <= max_power:
        yield 2 ** current_power
        current_power += 1

# Используем наш генератор точно так же, как и итератор
for num in power_of_two_gen(5):
    print(num)
# Вывод:
# 1
# 2
# 4
# 8
# 16
# 32

# Можно и вручную
gen_obj = power_of_two_gen(2)
print(next(gen_obj)) # -> 1
print(next(gen_obj)) # -> 2
print(next(gen_obj)) # -> 4
# print(next(gen_obj)) # -> вызовет StopIteration
```

Код стал значительно короче и понятнее, но результат и принцип работы (ленивые вычисления) остались теми же.

---

### 2. Выражения-генераторы (Generator Expressions)

Это еще более компактный способ создания генераторов, синтаксис которого очень похож на списковые включения (list comprehensions).

- **Списковое включение (List Comprehension)**: [x * x for x in range(5)]
    
    - **Результат**: Создает в памяти **полный список** [0, 1, 4, 9, 16].
        
    - **Память**: Сразу потребляет память под все элементы.
        
- **Выражение-генератор (Generator Expression)**: (x * x for x in range(5))
    
    - **Результат**: Создает **объект-генератор**, который будет вычислять значения по одному.
        
    - **Память**: Потребляет минимум памяти, так как значения генерируются "на лету".
        

**Пример:**

```python
# Создаем список - занимает память
my_list = [i for i in range(10000000)]
# print(sum(my_list)) # Сначала будет создан огромный список

# Создаем генератор - почти не занимает память
my_generator = (i for i in range(10000000))

# Функция sum может работать напрямую с генератором,
# обрабатывая по одному элементу за раз.
print(sum(my_generator))
```


Использование выражения-генератора здесь намного эффективнее.

> **Правило большого пальца**: Если вам нужен итоговый список для многократного использования, используйте списковое включение. Если вам нужно пройтись по последовательности один раз (например, для суммирования или в цикле for), используйте выражение-генератор.

---

### Популярные вопросы на собеседовании

- **"Что такое генератор и чем он отличается от обычной функции?"**
    
    - Ответ: Генератор — это функция, которая содержит ключевое слово yield. При вызове она возвращает объект-генератор (итератор), а не выполняет свой код. yield приостанавливает выполнение и возвращает значение, сохраняя состояние функции, в то время как return полностью завершает ее.
        
- **"В чем разница между списковым включением и выражением-генератором?"**
    
    - Ответ: Списковое включение (в квадратных скобках) создает и возвращает полный список в памяти. Выражение-генератор (в круглых скобках) создает объект-генератор, который вычисляет значения лениво, по одному, что гораздо эффективнее по памяти для больших последовательностей.
        
- **"Приведите пример, когда использование генератора предпочтительнее списка."**
    
    - Ответ: При обработке больших файлов (чтение по одной строке, а не всего файла в память), при работе с бесконечными последовательностями или при обработке данных из сети, когда данные поступают порциями. Любая ситуация, где объем данных велик или неизвестен, является хорошим кандидатом для использования генераторов.
        
- **"Можно ли 'перезапустить' генератор или пройти по нему дважды?"**
    
    - Ответ: Нет. Генератор, как и любой итератор, одноразовый. После того как он вызвал StopIteration, он исчерпан. Чтобы пройти по последовательности еще раз, нужно создать новый объект-генератор, снова вызвав генераторную функцию.
        

---