tags: [sql, postgresql, plpgsql, database, bigdata, interviewprep]  
alias: [PL/pgSQL, Хранимые процедуры, Триггеры, Функции в SQL]  
related: [[SQL]], [[Базы данных]], [[Оптимизация запросов в SQL]]

Когда возможностей декларативного SQL (SELECT, INSERT, UPDATE, DELETE) становится недостаточно, мы переходим к **PL/pgSQL** (Procedural Language/PostgreSQL). Это полноценный процедурный язык программирования, который позволяет писать сложную логику, исполняемую прямо на стороне сервера баз данных.

Ключевые возможности PL/pgSQL:

- Объявление переменных.
    
- Условия (IF-ELSEIF-ELSE).
    
- Циклы (LOOP, FOR, WHILE).
    
- Обработка исключений (BEGIN...EXCEPTION...END).
    

С помощью этого языка создаются три основных типа объектов: функции, процедуры и триггеры.

## [[Functions (Функции)]]

**Идея**: Функция — это подпрограмма, которая принимает аргументы, выполняет некоторые вычисления и **обязательно возвращает значение**.

**Аналогия**: Функция в любом языке программирования, например, в Python.

**Когда использовать?** Когда нужно инкапсулировать сложную логику вычислений и использовать её результат в SQL запросах.

**Ключевые характеристики:**

- Всегда есть RETURNS ... в определении.
    
- Вызывается внутри SQL-запросов (например, в SELECT или WHERE).
    
- Не может управлять транзакциями (COMMIT, ROLLBACK). Выполняется внутри транзакции вызвавшего её запроса.
    

**Синтаксис и Пример:**  
Предположим, у нас есть сложный расчет бонуса для сотрудника. Мы можем вынести его в функцию.
```SQL
CREATE FUNCTION calculate_employee_bonus(employee_id INT)
RETURNS NUMERIC AS $$
DECLARE
    employee_salary NUMERIC;
    bonus_rate NUMERIC := 0.1; -- 10%
BEGIN
    -- Находим зарплату сотрудника
    SELECT salary INTO employee_salary FROM employees WHERE id = employee_id;

    -- Простое вычисление, в реальности может быть сложная логика
    RETURN employee_salary * bonus_rate;
END;
$$ LANGUAGE plpgsql;

-- Использование функции в запросе:
SELECT
    name,
    salary,
    calculate_employee_bonus(id) AS bonus
FROM employees;
```
## [[Procedures (Хранимые процедуры)]]

**Идея**: Процедура — это подпрограмма, которая выполняет набор действий и **не возвращает значение**. Её главная цель — модификация данных или выполнение последовательности операций.

**Ключевые характеристики:**

- **Не возвращает значение** (нет RETURNS).
    
- Вызывается отдельной командой CALL.
    
- **Может управлять транзакциями**. Это её главное отличие от функции. Процедура может начинать, фиксировать (COMMIT) или откатывать (ROLLBACK) транзакции.
    

**Когда использовать?** Для выполнения сложных, многошаговых операций по изменению данных, например, в ETL-процессах. "Заархивировать старые заказы", "Пересчитать итоги за месяц".

**Синтаксис и Пример:**  
Процедура, которая повышает зарплату всем в отделе и логирует это действие.
```SQL
CREATE PROCEDURE give_raise_for_department(department_name TEXT, raise_amount NUMERIC)
AS $$
BEGIN
    -- Повышаем зарплату
    UPDATE employees
    SET salary = salary + raise_amount
    WHERE department = department_name;

    -- Записываем информацию об этом в другую таблицу
    INSERT INTO salary_log(details, execution_time)
    VALUES (format('Gave a raise of %s to department %s', raise_amount, department_name), now());
    
    -- Процедура может управлять транзакцией
    COMMIT;
END;
$$ LANGUAGE plpgsql;

-- Вызов процедуры:
CALL give_raise_for_department('IT', 5000);
```

## [[Triggers (Триггеры)]]

**Идея**: Триггер — это специальный тип функции, который **запускается автоматически** в ответ на определенное событие с таблицей (INSERT, UPDATE или DELETE).

**Аналогия**: "Сигнализация" или "событийный слушатель" (event listener), который следит за таблицей.

**Когда использовать?** Для реализации аудита, поддержания целостности данных, каскадных обновлений и другой "магии", которая должна происходить неявно для пользователя.

**Процесс создания триггера состоит из 2-х частей:**

1. **Триггерная функция**: Специальная функция, которая не принимает аргументов и возвращает особый тип TRIGGER. Внутри неё доступны переменные NEW (строка после изменения) и OLD (строка до изменения).
    
2. **Сам триггер**: Инструкция CREATE TRIGGER, которая "привязывает" триггерную функцию к таблице, событию (INSERT, UPDATE, DELETE) и времени срабатывания (BEFORE или AFTER).
    

**Синтаксис и Пример:** Создадим триггер для аудита изменений зарплат.
```SQL
-- 1. Создаем триггерную функцию
CREATE FUNCTION log_salary_changes()
RETURNS TRIGGER AS $$
BEGIN
    -- Если была изменена зарплата и новое значение не равно старому
    IF NEW.salary <> OLD.salary THEN
        INSERT INTO salary_log(employee_id, old_salary, new_salary, change_time)
        VALUES (OLD.id, OLD.salary, NEW.salary, now());
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 2. Привязываем триггер к таблице employees
CREATE TRIGGER employees_salary_audit
AFTER UPDATE ON employees
FOR EACH ROW -- Триггер срабатывает для каждой измененной строки
EXECUTE FUNCTION log_salary_changes();
```

Теперь любой UPDATE employees SET salary = ... автоматически вызовет этот триггер.

---

### Сводное сравнение

|   |   |   |   |
|---|---|---|---|
|Характеристика|Функция|Процедура|Триггер|
|**Как вызывается?**|SELECT, WHERE|CALL|Автоматически (при INSERT, UPDATE, DELETE)|
|**Возвращает значение?**|Да, обязательно (RETURNS)|Нет|Да, особый тип TRIGGER|
|**Управление транзакциями?**|Нет|Да (COMMIT, ROLLBACK)|Нет (выполняется в транзакции события)|
|**Основной сценарий**|Инкапсуляция вычислений|Сложные операции по изменению данных (ETL)|Аудит, автоматизация, поддержание целостности данных|

---

### Популярные вопросы на собеседовании

- **"В чем основное отличие функции от процедуры в PostgreSQL?"**
    
    - Ответ: Функция обязана вернуть значение и не может управлять транзакциями. Процедура не возвращает значение, но может управлять транзакциями (COMMIT/ROLLBACK).
        
- **"Когда вы предпочтете использовать триггер, а не процедуру?"**
    
    - Ответ: Триггер используется, когда логика должна срабатывать автоматически и неявно в ответ на изменение данных (например, аудит). Процедура используется, когда нужно выполнить сложную операцию по явной команде CALL.
        
- **"Каковы риски использования триггеров?"**
    
    - Ответ: "Скрытая логика" — поведение системы становится неочевидным. Сложность отладки — трудно понять, почему данные изменились. Производительность — большое количество триггеров или сложная логика в них может замедлить базовые операции INSERT/UPDATE/DELETE.