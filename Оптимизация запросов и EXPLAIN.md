tags: [sql, postgresql, database, optimization, interviewprep]  
alias: [Оптимизация запросов, План выполнения, EXPLAIN, EXPLAIN ANALYZE]  
related: [[SQL]], [[Индексы (Indexes)]], [[Транзакции и принципы ACID]], [[SELECT запросы в SQL]]

**Оптимизация запросов** — это процесс анализа и переписывания SQL-запросов (а также изменения структуры БД, например, добавления [[Индексы (Indexes)|индексов]]) с целью уменьшения времени их выполнения и потребляемых ресурсов (ЦПУ, память, I/O).

Главный инструмент для этого в PostgreSQL — команда EXPLAIN.

### EXPLAIN vs EXPLAIN ANALYZE

- EXPLAIN: Показывает **оценочный** план выполнения. Планировщик PostgreSQL "думает", что он будет делать, и сколько это будет стоить. Выполняется мгновенно, не исполняя сам запрос.
    
- EXPLAIN ANALYZE: **Выполняет** запрос и показывает **реальный** план выполнения с фактическим временем и количеством строк. Это ваш основной инструмент для поиска узких мест. **Осторожно**: не используйте EXPLAIN ANALYZE с запросами, которые меняют данные (INSERT, UPDATE, DELETE), если вы не хотите, чтобы эти изменения реально произошли!
    

---

## Как читать план выполнения

Вывод EXPLAIN представляет собой дерево **узлов (nodes)**. План читается **изнутри наружу** (от нижних узлов с наибольшим отступом к верхним). Каждый узел представляет одну операцию.

**Пример плана:**

--------------------------------------------------------------------------------------------------
 Hash Join  (cost=3.02..5.07 rows=50 width=8) (actual time=0.043..0.062 rows=50 loops=1)
   Hash Cond: (t2.id = t1.id)
   ->  Seq Scan on t2  (cost=0.00..1.50 rows=50 width=4) (actual time=0.005..0.010 rows=50 loops=1)
   ->  Hash  (cost=1.50..1.50 rows=50 width=4) (actual time=0.024..0.024 rows=50 loops=1)
         ->  Seq Scan on t1  (cost=0.00..1.50 rows=50 width=4) (actual time=0.003..0.008 rows=50 loops=1)


**Ключевые метрики для каждого узла:**

- cost: **Оценка** планировщика. cost=A..B. A — стоимость получения первой строки, B — стоимость получения всех строк. Не является реальным временем!
    
- rows: **Оценка** планировщика, сколько строк вернет этот узел.
    
- actual time: (из ANALYZE) **Реальное время** в миллисекундах. time=A..B. A — время до получения первой строки, B — общее время узла. **Это самая важная метрика.**
    
- rows: (из ANALYZE) **Реальное количество** строк, которое вернул узел.
    

> **Золотое правило оптимизации**: Найдите узел с самым большим actual time и начните анализ с него. Также обращайте внимание на большое расхождение между rows (оценка) и rows (реальность) — это говорит о неточной статистике.

---

## Основные типы узлов (Nodes)

### Сканирование таблиц:

- Seq Scan (Sequential Scan): **Потенциально плохо**. Последовательное чтение всей таблицы. На маленьких таблицах это нормально, на больших — это катастрофа и главный признак отсутствия индекса.
    
- Index Scan: **Хорошо**. Используется индекс для поиска нужных строк, а затем идет в таблицу, чтобы забрать их.
    
- Index-Only Scan: **Отлично**. Все необходимые для запроса данные были взяты прямо из [[Индексы (Indexes)|индекса]], обращение к таблице не потребовалось (покрывающий индекс).
    
- Bitmap Heap Scan / Bitmap Index Scan: Комбинированная операция. Сначала по индексу строится "карта" страниц диска, которые нужно посетить, а затем происходит чтение только этих страниц. Эффективно, когда индекс возвращает не слишком мало, но и не слишком много строк.
    

### Соединения (Joins):

- Nested Loop Join: Простой цикл. Для каждой строки из первой таблицы ищет совпадения во второй. Эффективен, если первая таблица очень маленькая, а на второй есть индекс по ключу соединения.
    
- Hash Join: Строит хеш-таблицу по одной (меньшей) из таблиц в памяти, а затем проходит по второй, проверяя совпадения по хешу. Эффективен для соединения больших таблиц, когда нет подходящих индексов. Требует много памяти (work_mem).
    
- Merge Join: Если обе таблицы отсортированы по ключу соединения, PostgreSQL может просто "слить" их. Очень эффективен, но требует предварительной сортировки.
    

### Другие:

- Sort: **Дорогая операция**. Говорит о том, что данные нужно было отсортировать (для ORDER BY, GROUP BY, Merge Join). Если вы видите Sort перед Merge Join, возможно, стоит создать индекс, который будет возвращать данные в уже отсортированном виде.
    
- Aggregate: Операции агрегации (GROUP BY). Часто используется HashAggregate.
    

---

## Практический процесс оптимизации

1. **Запустите EXPLAIN ANALYZE your_query;**
    
2. **Найдите "плохие" паттерны:**
    
    - **Seq Scan на большой таблице?**
        
        - **Решение**: Проверьте условия WHERE и ON в JOIN. Создайте B-Tree индекс на столбцах, которые там используются.
            
    - **Оценка rows сильно отличается от реальной?** (Например, rows=1 а в реальности rows=100000).
        
        - **Решение**: Статистика по таблице устарела. Запустите ANALYZE table_name;. Если не помогает, возможно, стоит увеличить детализацию статистики для конкретного столбца: ALTER TABLE ... ALTER COLUMN ... SET STATISTICS 1000;.
            
    - **Дорогая операция Sort?**
        
        - **Решение**: Можно ли избежать сортировки, создав индекс, который будет возвращать данные в нужном порядке?
            
    - **Неэффективный JOIN?** (Например, Nested Loop на двух больших таблицах).
        
        - **Решение**: Возможно, не хватает индекса на ключе соединения. Или стоит увеличить work_mem, чтобы планировщик выбрал Hash Join.
            
3. **Примените исправление** (например, CREATE INDEX ...).
    
4. **Вернитесь к шагу 1** и сравните новый план со старым. Убедитесь, что actual time уменьшился.
    

---

### Популярные вопросы на собеседовании

- **"Как бы вы подошли к оптимизации медленного SQL запроса?"**
    
    - Ответ: Начать с EXPLAIN ANALYZE, найти самый дорогой узел в плане, проанализировать его (например, Seq Scan на большой таблице), предложить решение (например, создать индекс) и проверить результат, сравнив планы до и после.
        
- **"Что означает cost в плане выполнения? Это время в секундах?"**
    
    - Ответ: Нет, это не время. Это условные единицы, которые планировщик использует для оценки "стоимости" операции. Они полезны для сравнения альтернативных планов, но для реальной оценки производительности нужно смотреть на actual time из EXPLAIN ANALYZE.
        
- **"Ваш EXPLAIN ANALYZE показывает, что планировщик ожидал 10 строк, а получил 1 миллион. Что это значит и что делать?"**
    
    - Ответ: Это ошибка оценки кардинальности. Статистика по таблице устарела или недостаточно детализирована. Первое, что нужно сделать — выполнить ANALYZE для этой таблицы. Если проблема остается, возможно, стоит увеличить default_statistics_target или настроить его для конкретного столбца.