tags: [python, bigdata, datastructures, algorithms, interviewprep]  
alias: [Python list, Python связный список]  
related: [[Algorithms and Data Structures]], [[Стеки (Stacks) и Очереди (Queues)]], [[Временная и Пространственная Сложность (Big O Notation)]]

В Python эти две фундаментальные структуры данных представлены по-разному:

- **Массив** реализован в виде встроенного типа данных list.
    
- **Связный список** не является встроенным типом и для решения алгоритмических задач обычно реализуется "вручную" с помощью классов.
    

Давайте разберем каждый из них подробно.

---

## [[Python list (Динамический массив)]]

Когда мы говорим "массив" в контексте Python, мы почти всегда имеем в виду list. Важно запомнить: **Python list — это не связный список, а динамический массив.**

Это означает, что "под капотом" list представляет собой непрерывный блок памяти.
# Создание списка (динамического массива)
my_list = [10, 20, 30, 40]

### Сложность операций для list

|   |   |   |
|---|---|---|
|Операция|Сложность|Пример Python кода|
|**Доступ по индексу**|[[O(1)]]|value = my_list[2]|
|**Добавление в конец**|[[O(1)]]*|my_list.append(50)|
|**Вставка в начало/середину**|[[O(n)]]|my_list.insert(0, 5)|
|**Удаление с конца**|[[O(1)]]|my_list.pop()|
|**Удаление с начала/середины**|[[O(n)]]|my_list.pop(0)|
|**Поиск элемента** (in)|[[O(n)]]|if 30 in my_list:|
|**Копирование (срез)**|[[O(k)]]|new_list = my_list[1:4] (где k - размер среза)|

*Амортизированная константная сложность. Иногда, когда массив переполняется, Python создает новый массив большего размера и копирует туда все элементы, что занимает O(n). Но это происходит редко, поэтому в среднем операция считается O(1).

### Преимущества и недостатки list

**(+) Плюсы:**

- Универсален и прост в использовании.
    
- Очень быстрый доступ к элементам по индексу (O(1)).
    
- Эффективен по памяти для хранения простых данных.
    

**(-) Минусы:**

- Медленные операции вставки и удаления в начале или середине списка (O(n)).
    

---

## [[Связные списки в Python (Linked Lists)]]

В Python нет встроенного класса для связного списка. На собеседованиях от вас ожидают, что вы сможете написать его сами.

**Структура:**

1. Класс **Node** (узел), который хранит данные (data) и ссылку на следующий узел (next).
    
2. Класс **LinkedList**, который хранит ссылку на первый узел (head).

# Классическая реализация односвязного списка
```python
```class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    # ... здесь будут методы для добавления, удаления и т.д.
```


### collections.deque — альтернатива для очередей

Когда в Python нужна производительность связного списка (быстрые добавления/удаления с обоих концов), в реальном коде почти всегда используют collections.deque (двусторонняя очередь).

> **collections.deque** реализован как **двусвязный список**, что обеспечивает [[O(1)]] для операций append, pop, appendleft и popleft. Это идеальная структура для реализации [[Очередь (Queue)|очередей]] и [[Стек (Stack)|стеков]].

### Сложность операций для связного списка

|   |   |   |
|---|---|---|
|Операция|Сложность|Объяснение|
|**Доступ/Поиск**|[[O(n)]]|Нужно перебирать элементы от head.|
|**Вставка/Удаление в начале**|[[O(1)]]|Меняем только head.|
|**Вставка/Удаление в конце**|[[O(n)]]*|*Нужно дойти до конца списка, чтобы добавить элемент.|

*Можно добиться O(1) для вставки в конец, если класс LinkedList будет хранить еще и указатель на хвост (tail). collections.deque делает это по умолчанию.


### Главный вывод для собеседования

**Вопрос:** "Когда вы выберете list, а когда deque (или связный список)?"

**Ответ:**

- "Я буду использовать **list** в большинстве случаев, особенно когда мне нужен частый доступ к элементам по индексу или когда я в основном добавляю/удаляю элементы в конец списка. Это стандартный выбор для хранения последовательностей."
    
- "Я выберу **collections.deque**, если мой главный сценарий — это частые добавления и удаления элементов с обоих концов. Например, для реализации очереди (FIFO) или стека (LIFO), где производительность операций popleft() и appendleft() критична."