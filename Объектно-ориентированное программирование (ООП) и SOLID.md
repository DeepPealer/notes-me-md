tags: [python, oop, solid, system-design, programming, interviewprep]  
alias: [ООП, SOLID, Объектно-ориентированное программирование]  
related: [[Python]], [[Паттерны проектирования (Design Patterns)]], [[Магические методы в Python]


**Объектно-ориентированное программирование (ООП)** — это парадигма программирования, основанная на концепции **"объектов"**. Объект — это сущность, которая объединяет в себе **данные (атрибуты)** и **поведение (методы)**.

> **Основная идея**: Вместо того чтобы описывать логику программы как последовательность действий, мы моделируем ее как взаимодействие между объектами реального или вымышленного мира.

Например, объект Автомобиль имеет атрибуты (цвет, скорость, марка) и методы (завести_двигатель(), ускориться()).

## Четыре столпа ООП

### 1. [[Инкапсуляция (Encapsulation)]]

- **Идея**: Объединение данных и методов, которые с ними работают, в один компонент (класс), и сокрытие внутренней реализации от внешнего мира. Доступ к данным осуществляется через публичные методы.
    
- **Аналогия**: Панель управления автомобиля. Вы используете руль и педали (публичный интерфейс), не зная, как именно работает двигатель или трансмиссия (скрытая реализация).
    
- **В Python**:
    
    - _ (одно подчеркивание): **Соглашение** о том, что атрибут или метод "защищенный" (protected) и не предназначен для использования извне. Но технически доступ остается.
        
    - __ (два подчеркивания): **Сокрытие** имени (name mangling). Python изменяет имя атрибута, чтобы избежать случайных конфликтов в дочерних классах. Это не настоящая приватность, но затрудняет прямой доступ.
	```python
	class BankAccount:
    def __init__(self, balance):
        self.__balance = balance # "Приватный" атрибут

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount

    def get_balance(self):
        return self.__balance
```


### 2. [[Наследование (Inheritance)]]

- **Идея**: Механизм, который позволяет создавать новый класс (потомок, дочерний) на основе существующего (родитель, базовый). Потомок "наследует" все атрибуты и методы родителя и может добавлять свои собственные или переопределять существующие. Описывает отношение "является" (is-a).
    
- **Аналогия**: Электромобиль является Автомобилем. Он наследует все его свойства, но добавляет свои, например, метод зарядить_батарею().
``` python
class Vehicle:
    def move(self):
        print("Транспорт движется")

class Car(Vehicle): # Car наследуется от Vehicle
    def honk(self):
        print("Би-бип!")

my_car = Car()
my_car.move() # -> "Транспорт движется" (унаследовано)
my_car.honk() # -> "Би-бип!" (собственный метод)
```


### 3. [[Полиморфизм (Polymorphism)]]

- **Идея**: "Много форм". Способность объектов с одинаковым интерфейсом (названиями методов) иметь разную реализацию этих методов. Это позволяет писать общий код, который может работать с объектами разных классов.
    
- **Аналогия**: У разных животных (Собака, Кошка, Птица) есть метод издать_звук(), но каждый выполняет его по-своему.
    
- **В Python**: Часто проявляется через **"утиную типизацию" (duck typing)**: "Если это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка". Нам не важен тип объекта, нам важно, что у него есть нужный нам метод.
```python
class Cat:
    def speak(self):
        return "Мяу"

class Dog:
    def speak(self):
        return "Гав"

def make_animal_speak(animal):
    print(animal.speak())

make_animal_speak(Cat()) # -> "Мяу"
make_animal_speak(Dog()) # -> "Гав"
```

### 4. [[Абстракция (Abstraction)]]

- **Идея**: Сокрытие ненужных деталей и предоставление пользователю только релевантной информации. Абстракция определяет "контракт" или "шаблон", которому должны следовать дочерние классы.
    
- **Аналогия**: Пульт от телевизора. У вас есть кнопки (интерфейс), но вы не видите и не взаимодействуете с его внутренними микросхемами (реализация).
    
- **В Python**: Реализуется с помощью **абстрактных базовых классов (ABC)** из модуля abc.
```python
from abc import ABC, abstractmethod

class AbstractShape(ABC):
    @abstractmethod # Декоратор, делающий метод абстрактным
    def area(self):
        pass

class Square(AbstractShape):
    def __init__(self, side):
        self.side = side
    
    # Мы обязаны реализовать этот метод
    def area(self):
        return self.side * self.side
```

## Принципы SOLID

SOLID — это акроним для пяти принципов проектирования в ООП, которые помогают создавать гибкие, масштабируемые и поддерживаемые системы.

#### S - **Single Responsibility Principle (Принцип единственной ответственности)**

> У класса должна быть только одна причина для изменения.

- **Простыми словами**: Каждый класс должен делать что-то одно и делать это хорошо.
    
- **Плохо**: Класс Report, который и генерирует данные для отчета, и сохраняет его в файл.
    
- **Хорошо**: Класс ReportGenerator и отдельный класс ReportSaver.
    

#### O - **Open/Closed Principle (Принцип открытости/закрытости)**

> Программные сущности (классы, модули, функции) должны быть открыты для расширения, но закрыты для изменения.

- **Простыми словами**: Вы должны иметь возможность добавлять новую функциональность, не изменяя существующий работающий код.
    
- **Как достичь?** Через наследование или композицию, используя абстракции.
    

#### L - **Liskov Substitution Principle (Принцип подстановки Барбары Лисков)**

> Объекты в программе должны быть заменяемы на экземпляры их подтипов без изменения правильности выполнения программы.

- **Простыми словами**: Если у вас есть код, работающий с классом Родитель, он должен так же корректно работать с любым Потомком, не зная об этом. Потомок не должен кардинально менять логику родителя.
    

#### I - **Interface Segregation Principle (Принцип разделения интерфейса)**

> Клиенты не должны быть вынуждены зависеть от методов, которые они не используют.

- **Простыми словами**: Лучше иметь много маленьких, специфичных интерфейсов (абстрактных классов), чем один большой и "жирный".
    
- **Плохо**: Интерфейс IWorker с методами work() и eat(). Класс Robot может работать, но не есть.
    
- **Хорошо**: Интерфейсы IWorkable и IEatable.
    

#### D - **Dependency Inversion Principle (Принцип инверсии зависимостей)**

> 1. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба должны зависеть от абстракций.
>     
> 2. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
>     

- **Простыми словами**: Вместо того чтобы класс Автомобиль сам создавал конкретный объект ДвигательV8, он должен получать "любой двигатель" (абстракцию IDвигатель) извне. Это позволяет легко подменять двигатели.
    

---

### Популярные вопросы на собеседовании

- **"Объясните четыре основных принципа ООП своими словами."**
    
- **"В чем разница между Абстракцией и Инкапсуляцией?"**
    
    - Ответ: Это тонкий момент. Абстракция — про сокрытие сложности и определение внешнего интерфейса (что объект делает). Инкапсуляция — про сокрытие данных и внутренней реализации (как он это делает).
        
- **"Что такое "утиная типизация" и с каким принципом ООП она связана?"**
    
    - Ответ: Связана с полиморфизмом.
        
- **"Расшифруйте любой из принципов SOLID и приведите пример."**
    

---