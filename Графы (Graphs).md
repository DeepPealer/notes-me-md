
tags: [python, bigdata, datastructures, algorithms, interviewprep]  
alias: [Граф, Обход в ширину, Обход в глубину, BFS, DFS]  
related: [[Algorithms and Data Structures]], [[Деревья (Trees)]], [[Стеки (Stacks) и Очереди (Queues) в Python]], [[Хеш-таблицы (Hash Tables)]]

Граф — это структура данных, состоящая из набора **вершин** (или узлов, nodes, vertices) и набора **ребер** (edges), которые соединяют пары вершин. В отличие от [[Деревья (Trees)|деревьев]], графы не имеют корневого элемента и могут содержать циклы.

**Аналогии:**

- **Социальная сеть**: люди — это вершины, дружба — это ребра.
    
- **Карта дорог**: города — это вершины, дороги — это ребра.
    
- **Интернет**: веб-страницы — это вершины, ссылки — это ребра.
    

### Основные типы графов

- **Неориентированный (Undirected)**: Ребра не имеют направления (если A связан с B, то и B связан с A). Пример: дружба в Facebook.
    
- **Ориентированный (Directed)**: Ребра имеют направление (связь от A к B не означает связь от B к A). Пример: подписка в Instagram.
    
- **Взвешенный (Weighted)**: Каждому ребру присвоено число (вес), которое может означать расстояние, стоимость, время и т.д. Пример: карта дорог с расстояниями между городами.
    
- **Невзвешенный (Unweighted)**: Все ребра считаются равнозначными.

### Способы представления графа в Python

На собеседовании от вас могут ожидать умения работать с графом, представленным одним из этих способов. Самый популярный — **список смежности**.

**1. Список смежности (Adjacency List)** - **Самый частый способ**  
Используется [[Хеш-таблицы (Hash Tables)|словарь]], где ключи — это вершины, а значения — списки их соседей.

```Python
# Пример неориентированного графа
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}
```

- **(+) Плюсы**: Эффективен по памяти для **разреженных** графов (где мало ребер). Быстрое получение всех соседей вершины.
    
- **(-) Минусы**: Проверка наличия ребра между двумя вершинами (A и D) требует O(k) времени, где k — число соседей у A.
    

**2. Матрица смежности (Adjacency Matrix)**  
Двумерный массив (список списков), где matrix[i][j] = 1 (или вес), если есть ребро между i-й и j-й вершинами, и 0 в противном случае.

- **(+) Плюсы**: Быстрая проверка наличия ребра (O(1)).
    
- **(-) Минусы**: Требует O(V²) памяти, где V — число вершин. Очень расточительно для разреженных графов.

## Алгоритмы обхода графа

Это фундаментальные алгоритмы, которые нужно знать наизусть. Их цель — посетить все доступные из стартовой точки вершины ровно один раз.

### Обход в ширину (Breadth-First Search, BFS)

BFS исследует граф "уровень за уровнем". Он сначала посещает всех непосредственных соседей стартовой вершины, затем соседей этих соседей и так далее.

- **Ключевая структура**: Использует [[Стеки (Stacks) и Очереди (Queues) в Python|Очередь (Queue)]] для хранения вершин, которые нужно посетить.
    
- **Применение**: Идеален для **поиска кратчайшего пути в невзвешенном графе**.

```Python
from collections import deque

def bfs(graph, start_node):
    visited = set()         # Множество для отслеживания посещенных вершин
    queue = deque([start_node]) # Очередь для вершин к посещению
    visited.add(start_node)

    while queue:
        vertex = queue.popleft() # Извлекаем первую вершину из очереди
        print(vertex, end=" ")

        for neighbor in graph.get(vertex, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
# Вызов: bfs(graph, 'A') -> A B C D E F 
```

### Обход в глубину (Depth-First Search, DFS)

DFS исследует граф, уходя "вглубь" по одному пути настолько, насколько это возможно, прежде чем вернуться и попробовать другой путь.

- **Ключевая структура**: Использует [[Стеки (Stacks) и Очереди (Queues) в Python|Стек (Stack)]]. Его можно реализовать явно или неявно через **[[Рекурсия (Recursion)|рекурсию]]** (используя системный стек вызовов).
    
- **Применение**: Поиск циклов, топологическая сортировка, решение задач (например, поиск выхода из лабиринта).

```Python
def dfs_recursive(graph, vertex, visited=None):
    if visited is None:
        visited = set()
    
    visited.add(vertex)
    print(vertex, end=" ")

    for neighbor in graph.get(vertex, []):
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited)
# Вызов: dfs_recursive(graph, 'A') -> A B D E F C (порядок может отличаться)
```
