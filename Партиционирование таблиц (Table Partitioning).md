tags: [data-engineering, database, postgresql, optimization, partitioning, interviewprep]  
alias: [Партиционирование, Секционирование таблиц]  
related: [[Индексы (Indexes)]], [[Sharding]], [[Оптимизация запросов в SQL]]

**Партиционирование** (или секционирование) — это техника, при которой одна большая, логическая таблица физически разделяется на несколько более мелких таблиц, называемых **партициями (partitions)**.

> **Основная идея**: Для пользователя и приложений партиционированная таблица выглядит как одна большая таблица. Но "под капотом" PostgreSQL хранит данные в отдельных физических таблицах и автоматически направляет запросы в нужную партицию.

**Важно**: В отличие от [[Sharding|шардирования]], партиционирование происходит в рамках **одного сервера (одного экземпляра) базы данных**. Это техника для управления большими таблицами, а не для распределения нагрузки по разным серверам.

### Проблемы, которые решает партиционирование

1. **Повышение производительности запросов (Query Performance)**
    
    - Когда вы делаете запрос с фильтром по ключу партиционирования (например, по дате), планировщик PostgreSQL может использовать **Partition Pruning** (отсечение партиций). Он понимает, что нужные данные лежат только в одной или нескольких партициях, и **не сканирует** все остальные. Это может на порядки ускорить запросы.
        
2. **Упрощение управления данными (Easier Data Management)**
    
    - Старые данные можно очень быстро удалять или архивировать, просто **отсоединяя (detach)** или **удаляя (drop)** целые партиции. Это мгновенная операция, в отличие от DELETE FROM ... WHERE ..., которая сканирует всю таблицу и генерирует огромное количество WAL-записей.
        
3. **Повышение производительности при массовой загрузке/удалении**.
    

---

### Типы партиционирования в PostgreSQL

PostgreSQL поддерживает три основных метода декларативного партиционирования:

#### 1. [[Range Partitioning (Партиционирование по диапазону)]]

- **Как работает?** Таблица делится на партиции на основе диапазона значений в столбце.
    
- **Идеально для**: **Данных временных рядов (time-series data)**, таких как логи, финансовые транзакции, метрики.
    
- **Пример**: Таблица logs партиционирована по месяцам.
    
    - logs_2023_01 (хранит записи WHERE log_date >= '2023-01-01' AND log_date < '2023-02-01')
        
    - logs_2023_02 (хранит записи WHERE log_date >= '2023-02-01' AND log_date < '2023-03-01')
        
    - ...и так далее.
        

**Синтаксис:**

```sql
-- 1. Создаем "мастер" или "родительскую" таблицу
CREATE TABLE logs (
    log_id SERIAL,
    log_date DATE NOT NULL,
    message TEXT
) PARTITION BY RANGE (log_date);

-- 2. Создаем партиции
CREATE TABLE logs_2023_01 PARTITION OF logs
    FOR VALUES FROM ('2023-01-01') TO ('2023-02-01');

CREATE TABLE logs_2023_02 PARTITION OF logs
    FOR VALUES FROM ('2023-02-01') TO ('2023-03-01');
```


Теперь запрос SELECT * FROM logs WHERE log_date = '2023-01-15'; будет сканировать **только** таблицу logs_2023_01.

#### 2. [[List Partitioning (Партиционирование по списку)]]

- **Как работает?** Таблица делится на основе **конкретных значений** в столбце.
    
- **Идеально для**: Категориальных данных с заранее известным, ограниченным набором значений.
    
- **Пример**: Таблица customers партиционирована по странам.
    
    - customers_usa (хранит записи WHERE country = 'USA')
        
    - customers_germany (хранит записи WHERE country = 'Germany')
        
    - customers_other (хранит все остальные, используя DEFAULT)
        

#### 3. [[Hash Partitioning (Партиционирование по хешу)]]

- **Как работает?** Таблица делится на основе хеша от значения в столбце.
    
- **Идеально для**: Равномерного распределения данных по партициям, когда нет очевидного ключа для диапазона или списка.
    
- **Пример**: Партиционирование большой таблицы users по user_id, чтобы распределить нагрузку на запись.
    

---

### Партиционирование vs. Шардирование

|   |   |   |
|---|---|---|
|Характеристика|Партиционирование (Partitioning)|Шардирование (Sharding)|
|**Масштаб**|**Одна** база данных, один сервер|**Множество** серверов (кластер)|
|**Основная цель**|Управление большими таблицами, производительность запросов|Горизонтальное масштабирование **записи и чтения**|
|**Реализация**|Встроенная функция СУБД (например, PostgreSQL)|Требует сложной инфраструктуры (MongoDB, Citus)|
|**Прозрачность**|Полностью прозрачно для приложения|Обычно требует маршрутизатора запросов|

> **Важно**: Эти концепции не исключают друг друга. Можно иметь **шардированный кластер**, где на каждом **шарде** есть **партиционированные** таблицы.

---

### Популярные вопросы на собеседовании

- **"Что такое партиционирование таблиц и зачем оно нужно?"**
    
- **"В чем разница между партиционированием и шардированием?"**
    
    - Ответ: Партиционирование — это разделение таблицы на части в рамках одного сервера для улучшения управляемости и производительности. Шардирование — это разделение всей базы данных по разным серверам для масштабирования нагрузки.
        
- **"У вас есть таблица с логами размером 5TB. Как бы вы ее оптимизировали для запросов за последний месяц?"**
    
    - Ответ: Я бы применил партиционирование по диапазону (Range Partitioning) по полю с датой (например, создал бы партиции на каждый месяц). Это позволило бы планировщику PostgreSQL использовать 'partition pruning' и при запросах за последний месяц сканировать только одну маленькую партицию вместо всей 5TB таблицы.
        
- **"Что такое 'Partition Pruning'?"**
    
    - Ответ: Это механизм оптимизации, при котором планировщик запросов определяет, что данные могут находиться только в определенных партициях, и исключает сканирование всех остальных партиций, что значительно ускоряет запрос.
        

---