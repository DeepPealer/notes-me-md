tags: [python, core-python, programming, interviewprep, iterators, memory-efficiency]  
alias: [Итераторы, Протокол итератора, Iterator Protocol]  
related: [[Python]], [[Генераторы и итераторы в Python]], [[Встроенные типы данных в Python (Lists, Dicts, Sets, Tuples)]]

**Итератор** — это объект, который позволяет последовательно перебирать элементы контейнера (например, списка или строки), не раскрывая его внутреннюю структуру. Он запоминает свое текущее состояние и знает, как получить следующий элемент.

> **Главное преимущество итераторов**: **Ленивые вычисления (Lazy evaluation)**. Итератор предоставляет элементы по одному, по мере необходимости. Это делает их невероятно эффективными по памяти, так как не нужно загружать все элементы в память сразу. Это критически важно для Big Data.

---

### Протокол итератора: \_\_iter\_\_ и \_\_next\_\_

Работа итераторов в Python определяется "протоколом итератора", который состоит из двух обязательных методов:

1. **__iter__()**: Этот метод должен возвращать сам объект-итератор. Он необходим, чтобы итераторы можно было использовать там же, где и итерируемые объекты (например, в цикле for).
    
2. **__next__()**: Этот метод возвращает следующий элемент из контейнера. Когда элементы заканчиваются, он должен вызвать исключение StopIteration.
    

### Как на самом деле работает цикл for

Когда вы пишете for element in my_list:, Python "под капотом" делает следующее:

1. Вызывает iter(my_list) (что, в свою очередь, вызывает my_list.__iter__()), чтобы получить объект-итератор.
    
2. Начинает цикл, в котором на каждой итерации вызывает next(iterator) (что вызывает iterator.__next__()), чтобы получить следующий элемент.
    
3. Присваивает этот элемент переменной element.
    
4. Когда iterator.__next__() вызывает исключение StopIteration, цикл for ловит его и завершает свою работу.
    

**Эквивалент цикла for на while:**

```python
my_list = [1, 2, 3]

# 1. Получаем итератор
iterator = iter(my_list)

# 2. Запускаем цикл
while True:
    try:
        # 3. Получаем следующий элемент
        element = next(iterator)
        print(element)
    except StopIteration:
        # 4. Ловим исключение и выходим из цикла
        break
```

### Итерируемый объект (Iterable) vs. Итератор (Iterator)

Это **ключевое различие**, которое часто спрашивают на собеседованиях.

- **Итерируемый объект (Iterable)** — это любой объект, из которого можно получить итератор. У него есть метод __iter__(). Примеры: list, tuple, str, dict, set, файлы. Это "контейнер" с данными.
    
- **Итератор (Iterator)** — это объект, который непосредственно осуществляет перебор. У него есть метод __next__() (который возвращает следующий элемент) и метод __iter__(), который возвращает self. Это "указатель", который движется по контейнеру.
    

> **Аналогия**:
> 
> - **Итерируемый объект** — это **книга**.
>     
> - **Итератор** — это **закладка** в этой книге. Вы можете иметь несколько закладок (итераторов) для одной и той же книги (итерируемого объекта), и каждая будет находиться на своей странице.


```python
my_list = [1, 2] # Итерируемый объект (Iterable)

# Получаем два независимых итератора из одного и того же объекта
iterator1 = iter(my_list)
iterator2 = iter(my_list)

print(next(iterator1)) # -> 1
print(next(iterator1)) # -> 2

print(next(iterator2)) # -> 1 (второй итератор начинает с начала)
```

### Создание собственного итератора

Чтобы создать свой итератор, нужно написать класс, реализующий протокол итератора.

**Пример**: Создадим итератор, который генерирует степени двойки.

```python
class PowerOfTwo:
    """Класс-итератор для генерации степеней двойки до max_power."""
    def __init__(self, max_power=0):
        self.max_power = max_power
        self.current_power = 0

    def __iter__(self):
        # Метод __iter__ должен возвращать сам объект
        return self

    def __next__(self):
        # Метод __next__ генерирует следующий элемент
        if self.current_power > self.max_power:
            # Если предел достигнут, вызываем StopIteration
            raise StopIteration

        result = 2 ** self.current_power
        self.current_power += 1
        return result

# Используем наш итератор
for num in PowerOfTwo(5):
    print(num)
# Вывод:
# 1
# 2
# 4
# 8
# 16
# 32
```

### Популярные вопросы на собеседовании

- **"В чем разница между итерируемым объектом и итератором?"**
    
    - Ответ: Итерируемый объект имеет метод __iter__ и содержит данные. Итератор имеет методы __iter__ и __next__, он хранит состояние и поставляет данные по одному. Итератор можно получить из итерируемого объекта с помощью функции iter().
        
- **"Как работает цикл for в Python?"**
    
    - Ответ: Он неявно вызывает iter() у объекта, чтобы получить итератор, а затем последовательно вызывает next() у этого итератора, пока не получит исключение StopIteration.
        
- **"Почему итераторы эффективны по памяти?"**
    
    - Ответ: Потому что они используют "ленивые вычисления", генерируя и возвращая только один элемент за раз. Это позволяет обрабатывать последовательности данных, которые потенциально не помещаются в оперативную память.
        
- **"Является ли итератор итерируемым объектом?"**
    
    - Ответ: Да. По протоколу, у итератора должен быть метод __iter__, который возвращает self. Это сделано для того, чтобы итератор можно было использовать в цикле for так же, как и итерируемый объект.