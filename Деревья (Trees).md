tags: [python, bigdata, datastructures, algorithms, interviewprep]  
alias: [Дерево, Бинарное дерево, Бинарное дерево поиска, BST]  
related: [[Algorithms and Data Structures]], [[Временная и Пространственная Сложность (Big O Notation)]], [[Рекурсия (Recursion)]], [[Стеки (Stacks) и Очереди (Queues) в Python]]

До сих пор мы рассматривали линейные структуры данных, где у каждого элемента есть "следующий" ([[Массивы и Связные списки в Python]]). **Дерево** — это **иерархическая** структура данных, которая состоит из узлов, соединенных ребрами.

**Аналогии:**

- Генеалогическое древо.
    
- Файловая система в компьютере (папки внутри папок).
    
- Структура HTML-документа (DOM).
    

### Ключевая терминология

- **Узел (Node)**: Элемент, хранящий данные и ссылки на другие узлы.
    
- **Корень (Root)**: Самый верхний узел, у которого нет "родителя". С него начинается дерево.
    
- **Ребро (Edge)**: Связь между двумя узлами.
    
- **Родитель (Parent)**: Узел, который ссылается на другие узлы.
    
- **Потомок (Child)**: Узел, на который ссылается родитель.
    
- **Лист (Leaf)**: Узел, у которого нет потомков.
    
- **Высота (Height)**: Длина самого длинного пути от узла до самого дальнего листа. Высота всего дерева — это высота его корня.
    
- **Глубина (Depth)**: Длина пути от корня до конкретного узла.

## Бинарное дерево (Binary Tree)

Это самый распространенный тип деревьев на собеседованиях. В бинарном дереве у каждого узла может быть **не более двух потомков**: левый (left) и правый (right).

## Бинарное дерево поиска (Binary Search Tree, BST)

Это особый вид бинарного дерева, который имеет важное свойство, позволяющее осуществлять очень быстрый поиск.

**Свойство BST**: Для любого узла N:

- Все значения в его **левом** поддереве **меньше**, чем значение N.data.
    
- Все значения в его **правом** поддереве **больше**, чем значение N.data.
    
- Оба его поддерева (левое и правое) также являются бинарными деревьями поиска.
    

> **Главное преимущество BST**: Это свойство позволяет очень быстро находить элементы, отсекая половину оставшегося дерева на каждом шаге, подобно бинарному поиску в массиве.


### Реализация в Python

Как и связные списки, деревья в Python обычно реализуются с помощью классов.

```Python
# Класс для узла дерева
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

# Пример простого бинарного дерева поиска
class BinarySearchTree:
    def __init__(self):
        self.root = None

    # Метод для вставки нового узла (часто рекурсивный)
    def insert(self, data):
        if self.root is None:
            self.root = Node(data)
        else:
            self._insert_recursive(data, self.root)

    def _insert_recursive(self, data, current_node):
        if data < current_node.data:
            if current_node.left is None:
                current_node.left = Node(data)
            else:
                self._insert_recursive(data, current_node.left)
        elif data > current_node.data:
            if current_node.right is None:
                current_node.right = Node(data)
            else:
                self._insert_recursive(data, current_node.right)
        # Если data == current_node.data, ничего не делаем (не храним дубликаты)
```

Заметка: [[Рекурсия (Recursion)]] является естественным и элегантным способом работы с деревьями, так как само дерево имеет рекурсивную природу (каждое поддерево — это тоже дерево).

---

### Сложность операций для BST (Big O)

|   |   |   |
|---|---|---|
|Операция|Средний случай (Сбалансированное дерево)|Худший случай (Разбалансированное дерево)|
|**Поиск**|[[O(log n)]]|[[O(n)]]|
|**Вставка**|[[O(log n)]]|[[O(n)]]|
|**Удаление**|[[O(log n)]]|[[O(n)]]|

- **Средний случай (O(log n))**: Дерево "пушистое" и хорошо сбалансировано. На каждом шаге мы отбрасываем примерно половину узлов.
    
- **Худший случай (O(n))**: Дерево вырождается в [[Массивы и Связные списки в Python|связный список]]. Это происходит, если вставлять элементы в отсортированном порядке (например, 1, 2, 3, 4, 5...). Каждый новый элемент будет просто добавляться справа.
    

> **На собеседовании**: Важно упомянуть оба случая. Средний O(log n) — это причина, по которой мы используем BST. Худший O(n) — это его главный недостаток. Существуют самобалансирующиеся деревья (AVL, Красно-чёрные), которые решают эту проблему, но обычно их реализацию писать не просят.


### Обходы деревьев (Tree Traversal)

Это алгоритмы для посещения всех узлов дерева в определенном порядке.

1. **Обход в глубину (Depth-First Search, DFS)**
    
    - **In-order (Симметричный)**: Лево -> Корень -> Право. Для BST этот обход вернет все элементы в отсортированном порядке!
        
    - **Pre-order (Прямой)**: Корень -> Лево -> Право. Полезен для копирования дерева.
        
    - **Post-order (Обратный)**: Лево -> Право -> Корень. Полезен для удаления узлов дерева.
        
2. **Обход в ширину (Breadth-First Search, BFS) / Level-order**
    
    - Посещает узлы уровень за уровнем. Для реализации этого обхода используется [[Стеки (Stacks) и Очереди (Queues) в Python|очередь]].
        

---

### Популярные вопросы на собеседовании

- **"Напишите функцию для поиска значения в BST."**
    
- **"Как проверить, является ли бинарное дерево бинарным деревом поиска?"**
    
    - Подвох: Недостаточно просто проверить свойство left < root < right для каждого узла. Нужно передавать в рекурсию допустимый диапазон значений (min/max).
        
- **"Найдите n-й по величине элемент в BST."**
    
    - Идея: Использовать In-order обход.
        
- **"Инвертируйте бинарное дерево."** (Знаменитый вопрос, который задали создателю Homebrew в Google).
    
    - Идея: Рекурсивно поменять местами левого и правого потомка для каждого узла.