tags: [python, core-python, interviewprep, concurrency, multiprocessing, parallelism]  
alias: [Многопроцессорность, Parallelism, Process, Pool]  
related: [[Python]], [[GIL (Global Interpreter Lock) and Threading]], [[Асинхронное программирование (async/await)]]

Модуль multiprocessing предоставляет API для создания и управления процессами, позволяя обходить **Global Interpreter Lock (GIL)** и достигать **истинного параллелизма** на многоядерных системах.

> **Основная идея**: Вместо создания потоков в рамках одного процесса, мы создаем совершенно новые, независимые процессы. Каждый процесс получает свой собственный интерпретатор Python, свою собственную память и, что самое главное, свой собственный GIL.

**Аналогия**: Если threading — это одна мастерская (процесс) с несколькими рабочими (потоками), которые вынуждены по очереди пользоваться одним главным инструментом (GIL), то multiprocessing — это строительство **нескольких независимых мастерских**, в каждой из которых есть свой полный набор инструментов.

**Когда использовать?** Прежде всего, для **CPU-bound задач** — тяжелых вычислений, которые могут быть распараллелены.

### Process — Базовый строительный блок

Класс multiprocessing.Process очень похож на threading.Thread. Он представляет собой один процесс, который будет выполнять заданную функцию.

**Важно**: Код, использующий multiprocessing, необходимо защищать конструкцией if __name__ == '__main__':. Это нужно потому, что дочерние процессы импортируют скрипт родителя, и без этой защиты они начнут рекурсивно создавать новые процессы до бесконечности.

```python
import multiprocessing
import time

def worker_function(name):
    """Функция, которую будет выполнять дочерний процесс."""
    print(f"Процесс {name}: Начал работу.")
    # Имитация CPU-bound работы
    _ = [i*i for i in range(10**7)]
    print(f"Процесс {name}: Закончил работу.")

if __name__ == '__main__':
    start_time = time.time()
    
    # Создаем объекты процессов
    p1 = multiprocessing.Process(target=worker_function, args=('A',))
    p2 = multiprocessing.Process(target=worker_function, args=('B',))

    # Запускаем процессы
    p1.start()
    p2.start()

    # Ждем завершения дочерних процессов
    p1.join()
    p2.join()

    end_time = time.time()
    print(f"Все процессы завершены за {end_time - start_time:.2f} секунд.")
```

Если у вас 2+ ядра, вы увидите, что общее время выполнения будет примерно равно времени выполнения одного процесса, а не их сумме.

---

### Pool — Управление пулом рабочих процессов

Создавать и управлять каждым процессом вручную неудобно. Для параллелизации обработки набора данных гораздо удобнее использовать multiprocessing.Pool. Он создает заданное количество рабочих процессов и распределяет задачи между ними.

**pool.map(function, iterable)** — это самый популярный метод. Он работает аналогично встроенной функции map, но распределяет вычисление function для каждого элемента iterable по разным процессам.

```python
import multiprocessing
import time

def square(x):
    return x * x

if __name__ == '__main__':
    # Создаем пул из 4 рабочих процессов
    # Если аргумент не указан, используется os.cpu_count()
    with multiprocessing.Pool(processes=4) as pool:
        data = range(10)
        
        start_time = time.time()
        
        # map блокирует выполнение, пока все задачи не будут завершены
        results = pool.map(square, data)
        
        end_time = time.time()

        print("Результаты:", results)
        print(f"Время выполнения: {end_time - start_time:.4f} секунд.")
```

### Обмен данными между процессами (Inter-Process Communication, IPC)

Так как процессы имеют **разные адресные пространства памяти**, они не могут обмениваться данными через общие переменные. Для этого multiprocessing предоставляет специальные инструменты.

1. **Queue**: Процессно-безопасная очередь, работающая по принципу FIFO. Отлично подходит для обмена данными между многими производителями и потребителями.
    
2. **Pipe**: Создает двусторонний канал связи между **двумя** процессами. Работает быстрее Queue, но менее гибок.
    

**Важно**: Все объекты, передаваемые через Queue или Pipe, должны быть **сериализуемыми (picklable)**. Python "консервирует" объект в одном процессе и "расконсервирует" в другом.

```python
from multiprocessing import Process, Queue

def producer(queue):
    """Помещает данные в очередь."""
    for i in range(5):
        queue.put(f"Сообщение {i}")
    queue.put(None) # Сигнал о завершении

def consumer(queue):
    """Забирает данные из очереди."""
    while True:
        item = queue.get()
        if item is None:
            break
        print(f"Потребитель получил: {item}")

if __name__ == '__main__':
    q = Queue()
    p1 = Process(target=producer, args=(q,))
    p2 = Process(target=consumer, args=(q,))
    p1.start()
    p2.start()
    p1.join()
    p2.join()
```

### Сравнение: multiprocessing vs. threading

|   |   |   |
|---|---|---|
|Характеристика|multiprocessing|threading|
|**Основной сценарий**|CPU-bound задачи|I/O-bound задачи|
|**Параллелизм**|**Истинный параллелизм** (обход GIL)|**Конкурентность** (ограничено GIL)|
|**Память**|Отдельное пространство памяти для каждого процесса (больше расход)|Общее пространство памяти (меньше расход)|
|**Обмен данными**|Сложный (через Queue, Pipe, требует сериализации)|Простой (через общие переменные, но требует блокировок)|
|**Создание**|Более медленное и ресурсоемкое|Быстрое и легковесное|

---

### Популярные вопросы на собеседовании

- **"Когда вы выберете multiprocessing, а когда threading?"**
    
    - Ответ: multiprocessing — для CPU-bound задач, где нужно задействовать все ядра процессора для вычислений. threading — для I/O-bound задач, чтобы эффективно использовать время, пока программа ждет ответа от сети или диска.
        
- **"Как процессы обмениваются информацией? Почему нельзя использовать глобальные переменные?"**
    
    - Ответ: Они используют механизмы IPC, такие как Queue или Pipe. Глобальные переменные использовать нельзя, потому что каждый процесс работает в своем изолированном пространстве памяти.
        
- **"В чем основные недостатки multiprocessing?"**
    
    - Ответ: Большее потребление памяти, более медленный запуск процессов и накладные расходы на сериализацию/десериализацию данных при межпроцессном взаимодействии.
        
- **"Что такое Pool и чем он полезен?"**
    
    - Ответ: Это пул рабочих процессов, который упрощает распараллеливание выполнения функции на наборе данных. Он абстрагирует ручное управление процессами и эффективно распределяет работу.