tags: [sql, postgresql, database, optimization, interviewprep]  
alias: [Индексы, Index, B-Tree, GIN, GiST, BRIN]  
related: [[SQL]], [[Оптимизация запросов в SQL]], [[SELECT запросы в SQL]], [[План выполнения запроса (EXPLAIN)]]

**Индекс** — это специальная структура данных, связанная с таблицей или представлением, которая служит для значительного ускорения операций поиска и извлечения данных.

> **Самая простая аналогия**: алфавитный указатель в конце книги. Вместо того чтобы пролистывать всю книгу в поисках нужного термина (это **Full Table Scan** или **Seq Scan**), вы смотрите в указатель, находите термин и номер страницы, а затем сразу переходите на нужную страницу. Это и есть **Index Scan**.

### Фундаментальный компромисс

Индексы не бесплатны. Они представляют собой классический компромисс в IT:

- **(+) Ускоряют чтение (SELECT)**: Поиск по индексированным столбцам происходит на порядки быстрее (сложность O(log n) вместо O(n)).
    
- **(-) Замедляют запись (INSERT, UPDATE, DELETE)**: При каждом изменении данных в таблице СУБД должна также обновить и все связанные с ней индексы.
    
- **(-) Занимают место на диске**: Индекс — это отдельная структура данных, которая хранится на диске.
    

---

### Как создать индекс

Базовый синтаксис очень прост:
```SQL
-- Создать индекс 'idx_employees_department' на столбец 'department' в таблице 'employees'
CREATE INDEX idx_employees_department ON employees (department);
```

Теперь запросы вида SELECT * FROM employees WHERE department = 'IT'; будут выполняться значительно быстрее.

---

### Типы индексов в PostgreSQL

PostgreSQL предлагает несколько типов индексов, каждый из которых оптимизирован для своих задач.

#### 1. [[B-Tree (B-дерево)]] — **Тип по умолчанию**

- **Идея**: Сбалансированное дерево, которое хранит отсортированные данные. Это самый универсальный и часто используемый тип индекса.
    
- **Когда использовать**: Практически всегда. Он идеально подходит для операторов сравнения: =, >, <, >=, <=, BETWEEN. Также используется для LIKE 'префикс%', IN.
    

#### 2. [[Hash (Хеш-индекс)]]

- **Идея**: Хеш-таблица, где ключ — это хеш от значения столбца.
    
- **Когда использовать**: Только для операций на точное равенство (=). Исторически он был быстрее B-Tree для таких операций, но B-Tree был улучшен и теперь в большинстве случаев является лучшим выбором.
    

#### 3. [[GIN (Generalized Inverted Index)]] — **Важно для Big Data**

- **Идея**: "Обратный" индекс, оптимизированный для поиска внутри **составных** типов данных. Он индексирует не сам элемент, а его составные части.
    
- **Когда использовать**:
    
    - **Полнотекстовый поиск**: Для поиска слов внутри текстовых документов (tsvector).
        
    - **Поиск в jsonb**: Для быстрого поиска ключей или значений внутри JSON-документа.
        
    - **Поиск в массивах**: Для проверки наличия элемента в массиве (@>).
        

#### 4. [[GiST (Generalized Search Tree)]]

- **Идея**: Обобщенное поисковое дерево, которое позволяет индексировать сложные, "пространственные" типы данных.
    
- **Когда использовать**:
    
    - **Географические данные (PostGIS)**: Для поиска объектов в определенном радиусе или пересекающихся полигонов.
        
    - Также может использоваться для полнотекстового поиска.
        

#### 5. [[BRIN (Block Range Index)]] — **Важно для Big Data**

- **Идея**: Очень легковесный индекс. Вместо того, чтобы хранить ссылку на каждую строку, он хранит только минимальное и максимальное значение для **большого блока** (диапазона) физических страниц на диске.
    
- **Когда использовать**: На **очень больших** таблицах, где данные имеют сильную естественную корреляцию с их физическим расположением. Классический пример — таблица логов с колонкой created_at типа timestamp. Данные, записанные в одно время, лежат на диске рядом. BRIN-индекс будет крошечным по сравнению с B-Tree, но очень эффективным.
    

---

### Продвинутые техники индексирования

- **Частичные индексы (Partial Indexes)**: Индекс, который создается не для всех строк, а только для тех, которые удовлетворяют определенному условию WHERE.
 ```SQL
	-- Индексируем только неоплаченные заказы.
	-- Индекс будет маленьким и эффективным.
	CREATE INDEX idx_orders_unpaid ON orders (order_id) WHERE status = 'unpaid';
	```
 
 * **Покрывающие индексы (Covering Indexes)**: Когда индекс содержит все столбцы, необходимые для выполнения запроса. В этом случае PostgreSQL может выполнить **Index-Only Scan**, вообще не обращаясь к основной таблице, что дает огромный прирост производительности. Для этого используется ключевое слово INCLUDE.
```SQL
-- Запрос: SELECT department, salary FROM employees WHERE department = 'IT';
-- Этот индекс "покрывает" запрос:
CREATE INDEX idx_emp_dept_salary ON employees (department) INCLUDE (salary);
```


### EXPLAIN: Как понять, что индекс используется?

Команда EXPLAIN (а лучше EXPLAIN ANALYZE) показывает план выполнения запроса.

- Seq Scan (Sequential Scan) — **плохо**. PostgreSQL читает всю таблицу.
    
- Index Scan — **хорошо**. Используется индекс для поиска.
    
- Index-Only Scan — **отлично**. Используется покрывающий индекс.
    

---

### Популярные вопросы на собеседовании

- **"У меня есть медленный SELECT запрос. Ваши первые шаги по его оптимизации?"**
    
    - Ответ: Первым делом я выполню EXPLAIN ANALYZE для этого запроса. Я посмотрю на план выполнения, чтобы понять, используются ли индексы. Если я увижу Seq Scan на большой таблице по столбцам из WHERE или JOIN, это будет первым кандидатом на создание индекса.
        
- **"В чем основной компромисс при использовании индексов?"**
    
    - Ответ: Мы обмениваем скорость записи (INSERT/UPDATE/DELETE) и дисковое пространство на значительное ускорение чтения (SELECT).
        
- **"У вас есть таблица с jsonb полем. Какой тип индекса вы будете использовать для поиска по ключам внутри этого jsonb?"**
    
    - Ответ: GIN (Generalized Inverted Index). Он специально предназначен для индексации составных типов данных, таких как jsonb или массивы.
        
- **"Когда не стоит создавать индекс?"**
    
    - Ответ: На маленьких таблицах (планировщик все равно выберет Seq Scan); на таблицах с очень частыми операциями записи и редкими чтениями; на столбцах с низкой кардинальностью (мало уникальных значений, например, "пол"), так как индекс будет неэффективен.