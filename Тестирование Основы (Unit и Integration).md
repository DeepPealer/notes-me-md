tags: [testing, qa, software-development, interviewprep]  
alias: [Тестирование, Unit-тесты, Интеграционные тесты, Пирамида тестирования]  
related: [[CI/CD]], [[Git]], [[Software Development Lifecycle]]

**Тестирование программного обеспечения** — это процесс проверки и верификации того, что программа или приложение работает так, как от него ожидается. Главная цель — найти ошибки (дефекты, баги) и убедиться в качестве продукта.

### Ключевые принципы тестирования

- **Тестирование показывает наличие дефектов, а не их отсутствие**. Если тесты не нашли ошибок, это не значит, что их нет. Это значит, что в данных тестовых сценариях ошибок не найдено.
    
- **Исчерпывающее тестирование невозможно**. Проверить все возможные комбинации вводов, состояний и путей выполнения даже в простой программе практически невозможно. Поэтому тестирование — это всегда управление рисками.
    
- **Раннее тестирование экономит время и деньги**. Чем раньше в цикле разработки найден баг, тем дешевле его исправить.
    
- **Дефекты скапливаются вместе (принцип Парето)**. Часто бывает, что 80% багов находятся в 20% модулей системы.
    
- **Парадокс пестицида**. Если вы постоянно прогоняете одни и те же тесты, они со временем перестанут находить новые баги. Тестовые сценарии нужно периодически пересматривать и обновлять.
    

---

### Пирамида тестирования

Это модель, которая помогает правильно распределить усилия по тестированию.

- **Основание Пирамиды: [[Unit-тесты (Модульные тесты)]]**
    
    - **Многочисленные, быстрые, дешевые.**
        
    - Проверяют самую маленькую, изолированную часть кода (одну функцию, один метод).
        
- **Середина: [[Интеграционные тесты]]**
    
    - **Меньше по количеству, медленнее, дороже.**
        
    - Проверяют, как несколько модулей системы работают вместе.
        
- **Вершина: End-to-End (E2E) / UI тесты**
    
    - **Очень мало, очень медленные, очень дорогие.**
        
    - Проверяют всю систему целиком с точки зрения пользователя.
        

---

## Unit-тесты (Модульные тесты)

- **Что это?** Тестирование наименьшей логической единицы кода (unit) в полной **изоляции** от остальной системы.
    
- **Цель**: Убедиться, что конкретная функция или метод работает правильно для разных входных данных.
    
- **Ключевая особенность**: Все внешние зависимости (обращения к базе данных, сети, другим классам) должны быть заменены на "заглушки" или "моки" (mocks/stubs).
    

> **Аналогия**: Вы тестируете двигатель автомобиля на специальном стенде, в изоляции от самого автомобиля. Вы проверяете, запускается ли он, как реагирует на "газ", не перегревается ли.

**Инструменты в Python:**

- unittest: Встроенная в Python библиотека, синтаксис которой похож на JUnit из Java.
    
- pytest: **Отраслевой стандарт де-факто**. Гораздо более мощный и лаконичный фреймворк, который позволяет писать тесты как простые функции с assert.
    

**Пример (с использованием pytest):**

```python
# файл: calculator.py
def add(a, b):
    return a + b

# файл: test_calculator.py
from calculator import add

def test_add_positive_numbers():
    assert add(2, 3) == 5

def test_add_negative_numbers():
    assert add(-1, -1) == -2
```

Запуск тестов из командной строки: pytest

---

## Integration-тесты (Интеграционные тесты)

- **Что это?** Тестирование взаимодействия между несколькими компонентами (модулями, сервисами) системы.
    
- **Цель**: Найти ошибки в "швах" или интерфейсах между частями системы.
    
- **Ключевая особенность**: В отличие от unit-тестов, здесь используются **реальные** зависимости. Если функция пишет в базу данных, интеграционный тест будет работать с настоящей (тестовой) базой данных.
    

> **Аналогия**: Вы устанавливаете протестированный двигатель в автомобиль и проверяете, как он работает вместе с коробкой передач, системой охлаждения и электроникой.

**Пример сценария для интеграционного теста:**

- Ваш сервис A вызывает по сети (API) сервис B.
    
- **Тест**: Запустить оба сервиса (или их тестовые версии), заставить сервис A сделать запрос и проверить, что сервис B правильно его обработал и вернул ожидаемый ответ.
    

---

### Сводное сравнение

|   |   |   |
|---|---|---|
|Характерика|Unit-тест|Интеграционный тест|
|**Область**|Одна функция/метод в изоляции|Взаимодействие нескольких модулей/сервисов|
|**Скорость**|Очень быстрая (миллисекунды)|Медленная (секунды)|
|**Зависимости**|Изолированы (используются "моки")|Реальные (настоящая БД, сетевые вызовы)|
|**Цель**|Проверить логику одной единицы|Проверить "швы" и контракты между компонентами|

---

### Популярные вопросы на собеседовании

- **"В чем разница между unit- и интеграционным тестированием?"**
    
- **"Что такое "пирамида тестирования" и о чем она говорит?"**
    
    - Ответ: Она говорит о том, что основу вашей тестовой стратегии должны составлять быстрые и дешевые unit-тесты, а более медленных и дорогих интеграционных и E2E тестов должно быть значительно меньше.
        
- **"Зачем "мокать" (mock) зависимости в unit-тестах?"**
    
    - Ответ: Чтобы обеспечить изоляцию. Это делает тест быстрым, предсказуемым (не зависит от состояния сети или БД) и позволяет тестировать только логику самого юнита, а не его зависимостей.
        
- **"Какие фреймворки для тестирования в Python вы знаете или использовали?"**
    
    - Ответ: unittest (встроенный) и pytest (сторонний, более популярный). Можно также упомянуть mock для создания заглушек.