tags: [sql, postgresql, database, bigdata, interviewprep, analytics]  
alias: [Оконные функции, Window Functions, Аналитические функции]  
related: [[SQL]], [[SELECT запросы в SQL]], [[Агрегатные функции в SQL]], [[Общие табличные выражения (CTE)]]

Оконная функция выполняет вычисление для набора строк, которые каким-либо образом связаны с текущей строкой. Это похоже на [[Агрегатные функции в SQL|агрегатную функцию]], но с одним ключевым отличием.

> **Главное отличие**: Обычные агрегатные функции с GROUP BY "схлопывают" (агрегируют) множество строк в одну. Оконная функция выполняет вычисление для каждой строки, основываясь на данных из "окна" (набора строк), и **не схлопывает** строки. Она возвращает результат для каждой строки.

### Базовый синтаксис

Ключевым элементом является OVER(), которое и определяет "окно".  
ФУНКЦИЯ() OVER ( [PARTITION BY ...] [ORDER BY ...] )

- PARTITION BY expr: Делит строки на разделы (партиции), по сути, на группы. Оконная функция будет применяться к каждой партиции независимо. **Это как GROUP BY, но без коллапса строк.**
    
- ORDER BY expr: Определяет порядок строк внутри каждой партиции. Это критически важно для функций, которые зависят от порядка (например, "накопительный итог" или "ранжирование").
    

Давайте снова воспользуемся нашей таблицей employees, но добавим еще пару записей для наглядности.

**Таблица employees:**  
| id | name | department | salary |  
|----|-------|------------|--------|  
| 1 | John | IT | 90000 |  
| 2 | Jane | HR | 75000 |  
| 3 | Peter | IT | 95000 |  
| 4 | Alice | Sales | 80000 |  
| 5 | Bob | Sales | 82000 |  
| 6 | Carol | IT | 90000 |

---

## Основные типы оконных функций

### 1. Агрегатные функции как оконные

Мы можем использовать стандартные агрегатные функции (SUM, AVG, COUNT, MAX, MIN) как оконные.

**Пример**: Вывести зарплату каждого сотрудника и среднюю зарплату по его отделу.
```SQL 
SELECT
    name,
    department,
    salary,
    AVG(salary) OVER (PARTITION BY department) AS avg_dept_salary
FROM employees;
```

**Результат:**  
| name | department | salary | avg_dept_salary |  
|-------|------------|--------|-------------------|  
| Jane | HR | 75000 | 75000.0 |  
| John | IT | 90000 | 91666.67 |  
| Peter | IT | 95000 | 91666.67 |  
| Carol | IT | 90000 | 91666.67 |  
| Alice | Sales | 80000 | 81000.0 |  
| Bob | Sales | 82000 | 81000.0 |  
Обратите внимание: строки не были схлопнуты. Каждый сотрудник получил значение средней зарплаты по своему отделу.

---

### 2. Функции ранжирования (Ranking Functions)

Это классика собеседований. Они присваивают ранг каждой строке внутри партиции.

- ROW_NUMBER(): Уникальный номер для каждой строки (1, 2, 3, 4...).
    
- RANK(): Присваивает одинаковый ранг строкам с одинаковыми значениями, но оставляет "пропуски" в нумерации (1, 2, 2, 4...).
    
- DENSE_RANK(): То же, что и RANK, но без "пропусков" (1, 2, 2, 3...).
    

**Пример**: Проранжировать сотрудников в каждом отделе по зарплате.

```SQL
SELECT
    name,
    department,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS rn,
    RANK()       OVER (PARTITION BY department ORDER BY salary DESC) AS rk,
    DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dr
FROM employees;
```

**Результат (отфильтрован по IT отделу для наглядности):**  
| name | department | salary | rn | rk | dr |  
|-------|------------|--------|----|----|----|  
| Peter | IT | 95000 | 1 | 1 | 1 |  
| John | IT | 90000 | 2 | 2 | 2 |  
| Carol | IT | 90000 | 3 | 2 | 2 |  
Смотрите, как ROW_NUMBER дал уникальные номера 2 и 3, в то время как RANK и DENSE_RANK присвоили им ранг 2, так как зарплаты одинаковы.

---

### 3. Функции смещения (Offset Functions)

Позволяют получить доступ к данным из предыдущей (LAG) или следующей (LEAD) строки в пределах партиции.

- LAG(value, offset, default): Возвращает value из строки, которая находится на offset строк **раньше** текущей.
    
- LEAD(value, offset, default): Возвращает value из строки, которая находится на offset строк **позже** текущей.
    

**Пример**: Показать для каждого сотрудника его зарплату и зарплату предыдущего по рангу сотрудника в том же отделе.
```SQL
SELECT
    name,
    department,
    salary,
    LAG(salary, 1, 0) OVER (PARTITION BY department ORDER BY salary DESC) AS previous_salary
FROM employees;
```

**Результат (отфильтрован по IT отделу):**  
| name | department | salary | previous_salary |  
|-------|------------|--------|-----------------|  
| Peter | IT | 95000 | 0 |  
| John | IT | 90000 | 95000 |  
| Carol | IT | 90000 | 90000 |  
У Peter'а нет предыдущего, поэтому стоит значение по умолчанию 0. У John'а предыдущая зарплата — Peter'а. У Carol — John'а.

---

### Популярные вопросы и задачи на собеседовании

- **"В чем разница между RANK() и DENSE_RANK()?"**
    
    - Ответ: Обе функции присваивают одинаковый ранг строкам с одинаковыми значениями в ORDER BY. Но RANK после группы с одинаковым рангом делает "пропуск" в последовательности (1, 2, 2, 4), а DENSE_RANK — нет (1, 2, 2, 3).
        
- **Задача "Top N per Group": "Найдите 3 самых высокооплачиваемых сотрудника в каждом отделе."**
    
    - Решение: Это классическая задача на оконные функции, которую почти невозможно решить элегантно без них.
```SQL
WITH RankedEmployees AS (
    SELECT
        name,
        department,
        salary,
        DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rnk
    FROM employees
)
SELECT name, department, salary
FROM RankedEmployees
WHERE rnk <= 3;
```

- **Задача "Month-over-Month Growth": "Для таблицы с продажами по месяцам посчитайте процент роста продаж от месяца к месяцу."**
    
    - Решение: Использовать LAG() чтобы получить продажи за предыдущий месяц, а затем в SELECT посчитать (current_sales - previous_sales) / previous_sales.

